# イーサネット
データリンク層を理解するために代表的なプロトコルであるEthernetを利用して学習していきましょう。
イーサネットは有線でコンピューター間通信を行うためのプロトコルです。通信を行うためには宛先を特定するためにアドレスが必要ですが、イーサネットはMACアドレスを利用します。

## MACアドレス
MACアドレスはネットワークインターフェースを一意に識別するための番号です。基本的に全世界でMACアドレスが重複することはありません。

(最近ではMACアドレスを変更できる機器も存在し、これを利用すると重複する可能性があります)

MACアドレスは48ビットで構成される番号です。MACアドレスを文字列で表現する際は8ビットごとに16進数に変換して、区切り文字で区切って表現します。
次のような形式で表されます。

`FF:FF:FF:FF:FF:FF`
`FF-FF-FF-FF-FF-FF`

## イーサネットフレーム
イーサネットでデータをやりとりするためのデータの形式をイーサネットフレームと呼びます。イーサネットフレームは次の形式で表現されます。
```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  プリアンブル  |  宛先MACアドレス  |  送信元MACアドレス  | タイプ |        データ        |  FCS  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    8byte     |      6byte      |      6byte       | 2byte |    46 ~ 1500byte    | 4byte |
```
イーサネットフレームはこれ以外にも存在しますが、現在最も使用されている仕様がこの形式で、Ethernet II(DIX)と呼びます。
イーサネットフレームにはデータを1500バイトまでしか保持することができません。そのため、1500バイト以上のデータを送信したい時はそれぞれの大きさが1500バイト内に収まるように送信したいデータを分割する必要があります。

これをフラグメント化 (Fragmentation)と呼びます。

この図を見てみると面白いことが分かります。データを送信するのに必要なデータ(これをヘッダと呼びます！)には、プリアンブル、宛先MACアドレス、送信元MACアドレス、タイプしか存在しません！しかも、プリアンブルは物理層で破棄されるので実際のところは宛先MACアドレス、送信元MACアドレス、タイプの3つだけです!
これはつまりどういうことなんでしょうか...?

## Let's ネットワーキング！
みなさんは他のコンピュータと通信するにはIPアドレスが必要でしょ？と考えているかもしれません。
でも実はコンピューター同士で情報通信を行うのに、IPアドレスは必要無いんです！

同じローカルエリアネットワーク（以下ネットワーク）に接続されたコンピュータ同士はイーサネットさえあれば通信することができるんです。
それを体験してもらいましょう！

### 準備
#### 実験環境の作成
まず、このリポジトリのトップディレクトリに移動してください。その後、次のコマンドを実行してください。
```shell
docker build -t networking-with-linux . 
```
ここで作成したDockerイメージが、今後実験を行うための環境になります。
実験環境のビルドが完了したら、次のコマンドを実行して立ち上げましょう。
```shell
docker run -it --privileged networking-with-linux bash
```

実行した後、
```shell
root@xxxxxxxxxxxx:/#
```
とターミナルに表示されていれば準備完了です！

### 実験!!!

#### ...その前に
まずは`ip link`とターミナルに入力して実行してみましょう。次のような結果が出力されたと思います。
```
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
13: eth0@if14: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
```
`ip link`を実行すると、そのマシンに存在するネットワークデバイスの一覧を取得することができます。

上の実行結果の読み方は次の通りです。(1つめだけ)
```
1: <デバイス名>: <対象デバイスの状態> mtu 65536 qdisc noqueue state <対象デバイスの起動状態> mode DEFAULT group default qlen 1000
    <デバイスの種類> <デバイスのMACアドレス> brd <デバイスのブロードキャストアドレス>
```
現時点で説明する必要が無い箇所については`<>`で囲っていないことに注意してください。

これに従って2つめを読み下すと、「デバイス名は`eth0`(@がついているときは@以下は読み飛ばしてください)で、`ブロードキャスト(BROADCAST)`、`マルチキャスト(MULTICAST)`が有効になっていて、`デバイスが有効になっていて(UP)`かつ`デバイスにケーブルが繋がっている(LOWER_UP)`。
デバイスの種類は`link/ether`で、MACアドレスは`02:42:ac:11:00:02`が割り当てられている。」ということになります。

ネットワークデバイスを利用して実際に通信を行う際、対象のネットワークデバイスは`UP`している必要があります。

これを実際に確認してみましょう。dockerコンテナのターミナル内でまずは
```shell
ip link
```
を実行して、名前が`lo`のデバイスが`UP`していることを確認してください。`lo`が`UP`していることを確認できたら、
```shell
python3 -m "http.server" 2>&1 >> /dev/null &
```
を実行してHTTPサーバーを立ち上げましょう。HTTPサーバーが起動できたら、
```shell
curl --head http://localhost:8000
```
を実行してレスポンスが返ってくることを確認してください。レスポンスが返ってくると、次のような内容が表示されると思います。
```
127.0.0.1 - - [05/Jun/2023 06:21:33] "HEAD / HTTP/1.1" 200 -
HTTP/1.0 200 OK
Server: SimpleHTTP/0.6 Python/3.10.11
Date: Mon, 05 Jun 2023 06:21:33 GMT
Content-type: text/html; charset=utf-8
Content-Length: 987
```
では、`lo`を`DOWN`にしたらどうなるか確認してみましょう。
```shell
ip link set lo down
ip link
```
を実行して`lo`の`state`が`DOWN`になっていることを確認してください。確認できたら先程と同じように
```shell
curl --head http://localhost:8000 
```
を実行してみましょう。しばらく待った後、`curl: (7) Failed to connect to localhost port 8000: Connection timed out`と表示されると思います。
これは`lo`ネットワークデバイスを`DOWN`にしたことが原因です。(明らかですね!)

これでネットワークデバイスは`UP`していないと通信ができないことを体感できたのではないでしょうか?

#### 本番!!!
ではいよいよイーサネットだけを使って他のコンピュータと通信してみましょう。
