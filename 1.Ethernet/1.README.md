# イーサネット
データリンク層を理解するために代表的なプロトコルであるEthernetを利用して学習していきましょう。
イーサネットは有線でコンピューター間通信を行うためのプロトコルです。通信を行うためには宛先を特定するためにアドレスが必要ですが、イーサネットはMACアドレスを利用します。

## MACアドレス
MACアドレスはネットワークインターフェースを一意に識別するための番号です。基本的に全世界でMACアドレスが重複することはありません。

(最近ではMACアドレスを変更できる機器も存在し、これを利用すると重複する可能性があります)

MACアドレスは48ビットで構成される番号です。MACアドレスを文字列で表現する際は8ビットごとに16進数に変換して、区切り文字で区切って表現します。
次のような形式で表されます。

`FF:FF:FF:FF:FF:FF`
`FF-FF-FF-FF-FF-FF`

## イーサネットフレーム
イーサネットでデータをやりとりするためのデータの形式をイーサネットフレームと呼びます。イーサネットフレームは次の形式で表現されます。
```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  プリアンブル  |  宛先MACアドレス  |  送信元MACアドレス  | タイプ |        データ        |  FCS  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    8byte     |      6byte      |      6byte       | 2byte |    46 ~ 1500byte    | 4byte |
```
イーサネットフレームはこれ以外にも存在しますが、現在最も使用されている仕様がこの形式で、Ethernet II(DIX)と呼びます。
イーサネットフレームにはデータを1500バイトまでしか保持することができません。そのため、1500バイト以上のデータを送信したい時はそれぞれの大きさが1500バイト内に収まるように送信したいデータを分割する必要があります。

これをフラグメント化 (Fragmentation)と呼びます。

この図を見てみると面白いことが分かります。データを送信するのに必要なデータ(これをヘッダと呼びます！)には、プリアンブル、宛先MACアドレス、送信元MACアドレス、タイプしか存在しません！しかも、プリアンブルは物理層で破棄されるので実際のところは宛先MACアドレス、送信元MACアドレス、タイプの3つだけです!
これはつまりどういうことなんでしょうか...?

## Let's ネットワーキング！
みなさんは他のコンピュータと通信するにはIPアドレスが必要でしょ？と考えているかもしれません。
でも実はコンピューター同士で情報通信を行うのに、IPアドレスは必要無いんです！

同じローカルエリアネットワーク（以下ネットワーク）に接続されたコンピュータ同士はイーサネットさえあれば通信することができるんです。
それを体験してもらいましょう！

### 実験環境の作成
まず、このリポジトリのトップディレクトリに移動してください。その後、次のコマンドを実行してください。
```shell
docker build -t networking-with-linux . 
```
ここで作成したDockerイメージが、今後実験を行うための環境になります。
実験環境のビルドが完了したら、次のコマンドを実行して立ち上げましょう。
```shell
docker run -it --privileged networking-with-linux bash
```

実行した後、
```shell
root@xxxxxxxxxxxx:/#
```
とターミナルに表示されていれば準備完了です！

### 実験!!!

#### ...その前に
まずは`ip link`とターミナルに入力して実行してみましょう。次のような結果が出力されたと思います。
```
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
13: eth0@if14: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
```
`ip link`を実行すると、そのマシンに存在するネットワークデバイスの一覧を取得することができます。

上の実行結果の読み方は次の通りです。(1つめだけ)
```
1: <デバイス名>: <対象デバイスの状態> mtu 65536 qdisc noqueue state <対象デバイスの起動状態> mode DEFAULT group default qlen 1000
    <デバイスの種類> <デバイスのMACアドレス> brd <デバイスのブロードキャストアドレス>
```
現時点で説明する必要が無い箇所については`<>`で囲っていないことに注意してください。

これに従って2つめを読み下すと、「デバイス名は`eth0`(@がついているときは@以下は読み飛ばしてください)で、`ブロードキャスト(BROADCAST)`、`マルチキャスト(MULTICAST)`が有効になっていて、`デバイスが有効になっていて(UP)`かつ`デバイスにケーブルが繋がっている(LOWER_UP)`。
デバイスの種類は`link/ether`で、MACアドレスは`02:42:ac:11:00:02`が割り当てられている。」ということになります。

ネットワークデバイスを利用して実際に通信を行う際、対象のネットワークデバイスは`UP`している必要があります。

これを実際に確認してみましょう。dockerコンテナのターミナル内でまずは
```shell
ip link
```
を実行して、名前が`lo`のデバイスが`UP`していることを確認してください。`lo`が`UP`していることを確認できたら、
```shell
python3 -m "http.server" 2>&1 >> /dev/null &
```
を実行してHTTPサーバーを立ち上げましょう。HTTPサーバーが起動できたら、
```shell
curl --head http://localhost:8000
```
を実行してレスポンスが返ってくることを確認してください。レスポンスが返ってくると、次のような内容が表示されると思います。
```
127.0.0.1 - - [05/Jun/2023 06:21:33] "HEAD / HTTP/1.1" 200 -
HTTP/1.0 200 OK
Server: SimpleHTTP/0.6 Python/3.10.11
Date: Mon, 05 Jun 2023 06:21:33 GMT
Content-type: text/html; charset=utf-8
Content-Length: 987
```
では、`lo`を`DOWN`にしたらどうなるか確認してみましょう。
```shell
ip link set lo down
ip link
```
を実行して`lo`の`state`が`DOWN`になっていることを確認してください。確認できたら先程と同じように
```shell
curl --head http://localhost:8000 
```
を実行してみましょう。しばらく待った後、`curl: (7) Failed to connect to localhost port 8000: Connection timed out`と表示されると思います。
これは`lo`ネットワークデバイスを`DOWN`にしたことが原因です。localhostを対象にサーバを立ち上げた場合、そのサーバのネットワークインターフェースには`lo`が割り当てられるからです。

これでネットワークデバイスは`UP`していないと通信ができないことを体感できたのではないでしょうか?

#### 準備
まずは実験環境で、ネットワークを作成しましょう!作成するネットワークは次のようになります。
コンピューターを2台用意して、LANケーブルで直接繋いでいるイメージです。

![あとで画像入れる]()

まずは、通信を行うコンピューター達を作成しましょう。
```shell
ip netns add host_1
ip netns add host_2
```
(今作成したのは厳密にはネットワーク名前空間ですが、今回においてはコンピューター自身と捉えて大丈夫です)

次に、コンピューター同士を繋ぐLANケーブルを作成しましょう
```shell
ip link add host_1_link type veth peer name host_2_link
```
実行した後、`ip link`を実行すると、次のような出力がされると思います。
```
# ...略
2: host_2_link@host_1_link: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether xxxxxxxxxxxxxxx brd ff:ff:ff:ff:ff:ff
3: host_1_link@host_2_link: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether xxxxxxxxxxxxxxx brd ff:ff:ff:ff:ff:ff
```
今作成された`host_1_link`、`host_2_link`それぞれがLANケーブルの両端にあたります。

それでは、作成したLANケーブルをそれぞれのコンピューター達に接続しましょう!
```shell
ip link set host_1_link netns host_1
ip link set host_2_link netns host_2
```
これらを実行することで、先程作成したコンピューター（ネットワーク名前空間）に移動します。試しに`ip link`を実行してみましょう。
先程まで存在した`host_1_link`、`host_2_link`が一覧から消えたのが分かると思います。

各コンピューターに移動した`host_1_link`、`host_2_link`をどのように確認すればよいでしょうか？
`ip`コマンドには作成したコンピューター内で実行するためのユーティリティが用意されています。
```shell
ip netns exec <名前> <コマンド>
```
で作成したコンピューター内でコマンドを実行することが可能になります。それでは実際に確認してみましょう。
```shell
ip netns exec host_1 ip link
```
これを実行すると、先程作成した`host_1_link`が存在することが確認できると思います。
`host_2`でも同じように確認してみましょう。

最後に`host_1_link`、`host_2_link`が通信をできるようにしましょう。作成されたばかりのネットワークデバイスは`DOWN`状態になっています。
なので、各コンピューター内で`ip link set <デバイス名> up`を行って起動しましょう。

#### 本番!!!

起動が完了したらいよいよ本題です。長かったですね...
イーサネットで直接通信を行うためのユーティリティとして`ethernet-echo-server`、`ethernet-echo-client`を用意しました。(ソースコードは/lib以下に存在します!)

これらを使って実際にMACアドレスだけで通信ができることを確認してみましょう!

まずはサーバーを起動しましょう。`host_1`、`host_2`どちらで起動してもよいのですが、今回は`host_1`でサーバーを起動することにしましょう。
```shell
ip netns exec host_1 ethernet-echo-server host_1
```
を実行することでサーバーを起動できます。`host_1`内でコマンドを実行するために`ip netns exec host_1`を先頭に書くことを忘れないでください!

`ethernet-echo-server`の使い方はシンプルで、引数に通信を監視したいネットワークデバイスの名前を指定するだけです。
Echoサーバーを起動できたら、Echoクライアントからメッセージを送信してみましょう!(サーバーを起動したターミナルとは別のターミナルから実行しましょう!)

```shell
ip netns exec host_2 ethernet-echo-client eth0 <宛先MACアドレス> <メッセージ>
```
`ethernet-echo-client`の使い方もシンプルではありますが、`ethernet-echo-server`に比べて引数が多くなっています。
第一引数に通信に利用するネットワークデバイスの名前、第二引数に宛先MACアドレスを指定します。
第三引数はメッセージですが、これはオプション引数です。

Echoクライアントからリクエストを送信すると、Echoサーバー側の標準出力に
```
02:42:ac:11:00:02 ---> 02:42:ac:11:00:02: type=unknown
message received "hello" via 02:42:ac:11:00:02
```
のような出力がされます。1行目矢印左側が送信元のMACアドレスで、矢印右側が宛先のMACアドレスです。
`type`はIP通信だとIPv4やIPv6となります。Echoクライアントから送信した場合はunknownとなります。

2行目にはEchoクライアントから送信されたメッセージが表示されます。

このように、MACアドレスだけでコンピューター同士が通信できることが分かったと思います.

### 課題
新たにコンピューター（ネットワーク名前空間）を追加して、そのコンピューターからEchoサーバーにリクエストを送信してください、 
